{"version":3,"sources":["/Users/ozan/code/giant-quadtree/node_modules/boilerplate-gulp/node_modules/browserify/node_modules/browser-pack/_prelude.js","/Users/ozan/code/giant-quadtree/src/node.js","/Users/ozan/code/giant-quadtree/src/quadtree.js"],"names":[],"mappings":"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","file":"GiantQuadtree.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nmodule.exports = Node;\n\nfunction Node(left, top, width, height, parent){\n\tthis.objects = [];\n\n\tthis.left = left;\n\tthis.top = top;\n\tthis.width = width;\n\tthis.height = height;\n\tthis.right = this.left + this.width;\n\tthis.bottom = this.top + this.height;\n\tthis.isBase = (this.width / 2) < this.minimumSize;\n\n\tthis.parent = parent;\n}\n\nNode.prototype.tl = void 0;\nNode.prototype.tr = void 0;\nNode.prototype.br = void 0;\nNode.prototype.bl = void 0;\n\nNode.prototype.objectLimit = 200;\nNode.prototype.minimumSize = 3000;\n\nNode.prototype.clear = function(){\n\tthis.objects = [];\n\n\tif(this.tl){\n\t\tthis.tl.clear();\n\t\tthis.tr.clear();\n\t\tthis.br.clear();\n\t\tthis.bl.clear();\n\t}\n};\n\nNode.prototype.getObjects = function(){\n\tif(this.tl){\n\t\treturn this.objects.concat(this.tl.getObjects(), this.tr.getObjects(), this.br.getObjects(), this.bl.getObjects());\n\t} else {\n\t\treturn this.objects.slice();\n\t}\n};\n\nNode.prototype.split = function(){\n\tvar childWidth = this.width / 2,\n\t\tchildHeight = this.height / 2,\n\t\tleft = this.left,\n\t\ttop = this.top;\n\n\tthis.tl = new Node(left, top, childWidth, childHeight, this);\n\tthis.tr = new Node(left + childWidth, top, childWidth, childHeight, this);\n\tthis.br = new Node(left + childWidth, top + childHeight, childWidth, childHeight, this);\n\tthis.bl = new Node(left, top + childHeight, childWidth, childHeight, this);\n};\n\n// This can be called from ANY node in the tree, it'll return the top most node of the tree\n// that can contain the element (it will grow the tree if nescessary)\nNode.prototype.parentNode = function(obj){\n\tvar node = this,\n\t\tparent;\n\n\t// If object is left of this node\n\tif(obj.left < node.left){\n\t\t// If object is to the top of this node\n\t\tif(obj.top < node.top){\n\t\t\t// Grow towards top left\n\t\t\tparent = node.grow(node.width, node.height);\n\t\t} else {\n\t\t\t// Grow towards bottom left\n\t\t\tparent = node.grow(node.width, 0);\n\t\t}\n\t// If object is right of this node\n\t} else if(obj.left + obj.width > node.left + node.width){\n\t\t// If object is to the top of this node\n\t\tif(obj.top < node.top){\n\t\t\t// Grow towards top right\n\t\t\tparent = node.grow(0, node.height);\n\t\t} else {\n\t\t\t// Grow towards bottom right\n\t\t\tparent = node.grow(0, 0);\n\t\t} \n\n\t// If object is within x-axis but top of node\n\t} else if(obj.top < node.top){\n\t\t// Grow towards top right (top left is just as valid though)\n\t\tparent = node.grow(0, node.height);\n\t// If object is within x-axis but bottom of node\n\t} else if(obj.top + obj.height > node.top + node.height){\n\t\t// Grow towards bottom right (bottom left is just as valid though)\n\t\tparent = node.grow(0, 0);\n\t}\n\t\n\t// If we had to grow, find the quadrant in the parent\n\tif(parent){\n\t\treturn parent.parentNode(obj);\n\t}\n\n\treturn node;\n};\n\n// Helper function which gets the quadrant node at a given x/y position\n// caller function has to check to see if this node is split before calling this\nNode.prototype.getQuadrantAt = function(x, y){\n\tif(!this.tl) return this;\n\n\tvar xMid = this.left + this.width / 2,\n\t\tyMid = this.top + this.height / 2;\n\n\tif(x < xMid){\n\t\tif(y < yMid){\n\t\t\treturn this.tl.tl && this.tl.getQuadrantAt(x, y) || this.tl;\n\t\t} else {\n\t\t\treturn this.bl.tl && this.bl.getQuadrantAt(x, y) || this.bl;\n\t\t}\n\t} else {\n\t\tif(y < yMid){\n\t\t\treturn this.tr.tl && this.tr.getQuadrantAt(x, y) || this.tr;\n\t\t} else {\n\t\t\treturn this.br.tl && this.br.getQuadrantAt(x, y) || this.br;\n\t\t}\n\t}\n};\n\n// Gets all the objects in quadrants within the given dimensions. \n// This assumes that the given dimensions can't be larger than a quadrant, \n// meaning it can at most touch 4 quadrants\nNode.prototype.getInteractableObjects = function(left, top, width, height){\n\tif(!this.tl) return this.objects.slice();\t\n\n\tvar node = this.getQuadrant(left, top, width, height),\n\t\tobjectsList = [node.objects],\n\t\tquadrants = [node], // Keeps track to prevent dupes\n\t\tparent = node.parent;\n\n\twhile(parent){\n\t\tobjectsList.push(parent.objects);\n\t\tquadrants.push(parent);\n\t\tparent = parent.parent;\n\t}\n\n\tif(node.tl){\n\t\t// top left corner\n\t\tvar quadrant = node.getQuadrantAt(left, top);\n\t\tif(!~quadrants.indexOf(quadrant)){\n\t\t\tquadrants.push(quadrant);\n\t\t\tobjectsList.push(quadrant.objects);\n\n\t\t\tif(quadrant.parent && !~quadrants.indexOf(quadrant.parent)){\n\t\t\t\tquadrants.push(quadrant.parent);\n\t\t\t\tobjectsList.push(quadrant.parent.objects);\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t// top right corner\n\t\tquadrant = node.getQuadrantAt(left + width, top);\n\t\tif(!~quadrants.indexOf(quadrant)){\n\t\t\tquadrants.push(quadrant);\n\t\t\tobjectsList.push(quadrant.objects);\n\n\t\t\tif(quadrant.parent && !~quadrants.indexOf(quadrant.parent)){\n\t\t\t\tquadrants.push(quadrant.parent);\n\t\t\t\tobjectsList.push(quadrant.parent.objects);\t\n\t\t\t}\n\t\t}\n\n\t\t// bottom right corner\n\t\tquadrant = node.getQuadrantAt(left + width, top + height);\n\t\tif(!~quadrants.indexOf(quadrant)){\n\t\t\tquadrants.push(quadrant);\n\t\t\tobjectsList.push(quadrant.objects);\n\n\t\t\tif(quadrant.parent && !~quadrants.indexOf(quadrant.parent)){\n\t\t\t\tquadrants.push(quadrant.parent);\n\t\t\t\tobjectsList.push(quadrant.parent.objects);\t\n\t\t\t}\n\t\t}\n\n\t\t// bottom left corner\n\t\tquadrant = node.getQuadrantAt(left, top + height);\n\t\tif(!~quadrants.indexOf(quadrant)){\n\t\t\tquadrants.push(quadrant);\n\t\t\tobjectsList.push(quadrant.objects);\n\t\t\tif(quadrant.parent && !~quadrants.indexOf(quadrant.parent)) objectsList.push(quadrant.parent.objects);\n\t\t}\n\t}\n\n\treturn Array.prototype.concat.apply([], objectsList);\n};\n\n// Gets the quadrant a given bounding box dimensions would be inserted into\nNode.prototype.getQuadrant = function(left, top, width, height){\n\tif(!this.tl) return this;\n\n\tvar\txMid = this.left + this.width / 2,\n\t\tyMid = this.top + this.height / 2,\n\t\ttopQuadrant = (top < yMid) && ((top + height) < yMid),\n\t\tbottomQuadrand = top > yMid;\n\n\tif((left < xMid) && ((left + width) < xMid)){\n\t\tif(topQuadrant){\n\t\t\treturn this.tl.tl && this.tl.getQuadrant(left, top, width, height) || this.tl;\n\t\t} else if(bottomQuadrand){\n\t\t\treturn this.bl.tl && this.bl.getQuadrant(left, top, width, height) || this.bl;\n\t\t}\n\t} else if(left > xMid){\n\t\tif(topQuadrant){\n\t\t\treturn this.tr.tl && this.tr.getQuadrant(left, top, width, height) || this.tr;\n\t\t} else if(bottomQuadrand) {\n\t\t\treturn this.br.tl && this.br.getQuadrant(left, top, width, height) || this.br;\n\t\t}\n\t}\n\n\treturn this;\n};\n\n// Inserts the object to the Node, spliting or growing the tree if nescessary\n// Returns the top-most node of this tree\nNode.prototype.insert = function(obj){\n\tvar quadrant,\n\t\tindex,\n\t\tlength,\n\t\tremainingObjects,\n\t\tobjects,\n\t\tnode;\n\n\t// This call will grow the tree if nescessary and return the parent node\n\t// if the tree doesn't need to grow, `node` will be `this`.\n\tnode = this.parentNode(obj);\n\tquadrant = node.getQuadrant(obj.left, obj.top, obj.width, obj.height);\n\n\tif(quadrant !== node){\n\t\tquadrant.insert(obj);\n\t} else {\n\t\tobjects = node.objects;\n\t\tobjects.push(obj);\n\n\t\tindex = 0;\n\t\tlength = objects.length;\n\t\tif(!this.isBase && length > node.objectLimit){\n\t\t\t// Split if not already split\n\t\t\tif(!node.tl) node.split();\n\n\t\t\t// For objects that don't fit to quadrants\n\t\t\tremainingObjects = [];\n\t\t\n\t\t\t// Iterate through all object and try to put them in a\n\t\t\t// Quadrant node, if that doesn't work, retain them\t\n\t\t\tfor(; index < length; index++){\n\n\t\t\t\t// Reusing the obj var\n\t\t\t\tobj = node.objects[index];\n\t\t\t\tquadrant = node.getQuadrant(obj.left, obj.top, obj.width, obj.height);\n\t\t\t\tif(quadrant !== node){\n\t\t\t\t\tquadrant.insert(obj);\n\t\t\t\t} else {\n\t\t\t\t\tremainingObjects.push(obj);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode.objects = remainingObjects;\n\t\t}\n\t}\n\n\treturn node;\n};\n\n// Creates a pre-split parent Node and attaches this Node as a\n// node at the given x/y offset (so 0,0 would make this Node the top left node)\nNode.prototype.grow = function(xOffset, yOffset){\n\tvar left = this.left - xOffset,\n\t\ttop = this.top - yOffset,\n\t\tparent = new Node(left, top, this.width * 2, this.height * 2);\n\t\n\tthis.parent = parent;\n\n\tif(xOffset){\n\t\tif(yOffset){\n\t\t\tparent.br = this;\n\t\t} else {\n\t\t\tparent.tr = this;\n\t\t}\n\t} else if(yOffset) {\n\t\tparent.bl = this;\n\t} else {\n\t\tparent.tl = this;\n\t}\n\n\tparent.tl = parent.tl || new Node(left, top, this.width, this.height, this);\n\tparent.tr = parent.tr || new Node(left + this.width, top, this.width, this.height, this);\n\tparent.br = parent.br || new Node(left + this.width, top + this.height, this.width, this.height, this);\n\tparent.bl = parent.bl || new Node(left, top + this.height, this.width, this.height, this);\n\n\treturn parent;\n};\n\n","'use strict';\n\nvar TreeNode = require('./node');\n\n/* Quadtree by Ozan Turgut (ozanturgut@gmail.com)\n\n   A Quadtree is a structure for managing many nodes interacting in space by\n   organizing them within a tree, where each node contains elements which may\n   interact with other elements within the node. This is particularly useful in\n   collision detection, in which a brute-force algorithm requires the checking of\n   every element against every other element, regardless of their distance in space.\n\n   This quadtree handles object in 2d space by their bounding boxes. It splits\n   a node once it exceeds the object limit per-node. When a node is split, it's\n   contents are divied up in to 4 smaller nodes to fulfill the per-node object limit.\n   Nodes are infinitely divisible.\n\n   If an object is inserted which exceeds the bounds of this quadtree, the quadtree\n   will grow in the direction the object was inserted in order to encapsulate it. This is\n   similar to a node split, except in this case we create a parent node and assign the existing\n   quadtree as a quadrant within it. This allows the quadtree to contain any object, regardless of\n   its position in space.\n\n   One function is exported which creates a quadtree given a width and height.\n\n   The quadtree api has two methods:\n\n   insert(bounds)\n   \t\tInserts a bounding box (it should contain an left, top, width, and height property).\n\n   \tretrieve(bounds)\n   \t\tRetrieves a list of bounding boxes that share a node with the given bounds object.\n*/\n\nvar Quadtree = module.exports = function(width, height){\n\tif(width){\n\t\tthis.width = width;\n\t\tthis.height = height? height : width;\n\t}\n\t\n\tthis.reset();\n};\n\nQuadtree.create = function(width, height){\n\tvar quadtree = new Quadtree(width, height);\n\treturn Quadtree.getApi(quadtree);\n};\n\nQuadtree.getApi = function(quadtree){\n\tvar api = {};\n\tapi.insert = quadtree.insert.bind(quadtree);\n\tapi.reset = quadtree.reset.bind(quadtree);\n\tapi.getObjects = quadtree.getObjects.bind(quadtree);\n\tapi.get = api.getObjects; // alias\n\tapi.prune = quadtree.prune.bind(quadtree);\n\n\treturn api;\n};\n\nQuadtree.prototype.width = 10000;\nQuadtree.prototype.height = 10000;\n\nQuadtree.prototype.reset = function(x, y){\n\tx = x || 0;\n\ty = y || 0;\n\n\tthis.top = new TreeNode(x, y, this.width, this.height);\n};\n\nQuadtree.prototype.insert = function(obj){\n\tthis.top = this.top.insert(obj);\n};\n\n/*\nfunction isInNode(node, left, top, right, bottom){\n\treturn node.left <= left && node.top <= top && node.right >= right && node.bottom >= bottom;\n}\n*/\n\nfunction getContainingNodeHelper(left, top, right, bottom, node){\n\tif(!node.tl) return node;\n\n\tif(left < node.tr.left){\n\t\tif(right < node.tr.left){\n\t\t\tif(bottom < node.bl.top){\n\t\t\t\treturn getContainingNodeHelper(left, top, right, bottom, node.tl);\n\t\t\t} else if(top > node.bl.top) {\n\t\t\t\treturn getContainingNodeHelper(left, top, right, bottom, node.bl);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif(bottom < node.br.top){\n\t\t\treturn getContainingNodeHelper(left, top, right, bottom, node.tr);\n\t\t} else if(top > node.br.top) {\n\t\t\treturn getContainingNodeHelper(left, top, right, bottom, node.br);\n\t\t}\n\t}\n\n\treturn node;\n}\n\nQuadtree.prototype.getContainingNode = function(left, top, right, bottom){\n\tif(left < this.top.left || \n\t\ttop < this.top.top || \n\t\tright > this.top.right || \n\t\tbottom > this.top.bottom){\n\t\treturn;\t\n\t}\n\n\treturn getContainingNodeHelper(left, top, right, bottom, this.top);\n};\n\nQuadtree.prototype.minimumSize = 3000;\nQuadtree.prototype.getInteractableObjects = function(left, top, right, bottom){\n\tvar self = this,\n\t\tminimumSize = this.minimumSize,\n\t\ttl = this.getContainingNode(left, top, left + 1, top + 1),\n\t\ttr,\n\t\tbl,\n\t\tbr,\n\t\tobjectsList = tl ? [tl.getObjects()] : [];\n\n\tfunction addAncestorElements(left, top, right, bottom){\n\t\tvar ancestor = self.getContainingNode(left, top, right, bottom);\n\t\tif(ancestor && !~objectsList.indexOf(ancestor.objects)) objectsList.push(ancestor.objects);\n\t}\n\n\tif(!tl || tl.right < right){\n\t\ttr = this.getContainingNode(right - 1, top, right, top + 1);\n\t\tif(tr) objectsList.push(tr.getObjects());\n\t\telse tr = tl;\n\t} else {\n\t\ttr = tl;\n\t}\n\n\tif(!tl || tl.bottom < bottom){\n\t\tbl = this.getContainingNode(left, bottom - 1, left + 1, bottom);\n\t\tif(bl) objectsList.push(bl.getObjects());\n\t\telse bl = tl;\n\t} else {\n\t\tbl = tl;\n\t}\n\n\tif(!tr || tr.bottom < bottom){\n\t\tif(!bl || bl.right < right){\n\t\t\tbr = this.getContainingNode(right - 1, bottom - 1, right, bottom);\n\t\t\tif(br) objectsList.push(br.getObjects());\n\t\t\telse br = bl;\n\t\t} else {\n\t\t\tbr = bl;\n\t\t}\n\t} else {\n\t\tbr = tr;\n\t}\n\t\n\tif(tl !== tr) addAncestorElements(left, top, right, top + 1);\n\tif(tr !== br) addAncestorElements(right - 1, top, right, bottom);\n\tif(br !== bl) addAncestorElements(left, bottom - 1, right, bottom);\n\tif(bl !== tl) addAncestorElements(left, top, left + 1, bottom);\n\t\t\n\t// Intersections towards top left\n\tif(tl){\n\t\tif((left - minimumSize) < tl.left){\n\t\t\taddAncestorElements(left - minimumSize, top, left + 1, top + 1);\n\t\t}\n\n\t\tif((top - minimumSize) < tl.top){\n\t\t\taddAncestorElements(left, top - minimumSize, left + 1, top + 1);\n\t\t}\n\t}\n\t\n\t// Intersections towards top right\n\tif(tr){\n\t\tif(tr !== tl && (top - minimumSize) < tr.top){\n\t\t\taddAncestorElements(right - 1, top - minimumSize, right, top + 1);\n\t\t}\n\n\t\tif((right + minimumSize) > tr.right){\n\t\t\taddAncestorElements(right - 1, top, right + minimumSize, top + 1);\n\t\t}\n\t}\n\n\t// Intersections towards bottom right\n\tif(br){\n\t\tif(br !== tr && (right + minimumSize) > br.right){\n\t\t\taddAncestorElements(right - 1, bottom - 1, right + minimumSize, bottom);\n\t\t}\n\n\t\tif((bottom + minimumSize) > br.bottom){\n\t\t\taddAncestorElements(right - 1, bottom - 1, right, bottom + minimumSize);\n\t\t}\n\t}\n\n\t// Intersections towards bottom left\n\tif(bl){\n\t\tif(bl !== br && (bottom + minimumSize) > bl.bottom){\n\t\t\taddAncestorElements(left, bottom - 1, left + 1, bottom + minimumSize);\n\t\t}\n\n\t\tif(bl !== tl && (left - minimumSize) < bl.left){\n\t\t\taddAncestorElements(left - minimumSize, bottom - 1, left + 1, bottom);\n\t\t}\n\t}\n\n\treturn Array.prototype.concat.apply([], objectsList);\n};\n\nQuadtree.prototype.getObjects = function(left, top, width, height){\n\tif(left !== void 0){\n\t\tvar bottom = top + height,\n\t\t\tright = left + width,\n\t\t\trectangles = this.getInteractableObjects(left, top, right, bottom),\n\t\t\trectangleIndex = rectangles.length,\n\t\t\tresult = [],\n\t\t\trectangle;\n\n\t\twhile(rectangleIndex--){\n\t\t\trectangle = rectangles[rectangleIndex];\n\t\t\t\n\t\t\t// If there is intersection along the y-axis\n\t\t\tif(\t(top <= rectangle.top ?\n\t\t\t\t\t(bottom >= rectangle.top) :\n\t\t\t\t\t(rectangle.bottom >= top)) && \n\t\t\t\t// And if there is intersection along the x-axis\n\t\t\t\t(left <= rectangle.left ? \n\t\t\t\t\t(right >= rectangle.left) :\n\t\t\t\t\t(rectangle.right >= left))){\n\n\t\t\t\t\n\t\t\t\tresult.push(rectangle);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\n\treturn this.top.getObjects();\n};\n\nQuadtree.prototype.prune = function(left, top, width, height){\n\tvar right = left + width,\n\t\tbottom = top + height,\n\t\tcandidate,\n\t\trejectedObjects = [],\n\t\tkeptObjects = [];\n\n\tvar objects = this.top.getObjects(),\n\t\tindex = 0,\n\t\tlength = objects.length;\n\n\tfor(; index < length; index++){\n\t\tcandidate = objects[index];\n\n\t\tif(\tcandidate.left < left || \n\t\t\tcandidate.top < top || \n\t\t\t(candidate.left + candidate.width) > right ||\n\t\t\t(candidate.top + candidate.height) > bottom){\n\t\t\trejectedObjects.push(candidate);\n\t\t} else {\n\t\t\tkeptObjects.push(candidate);\n\t\t}\n\t}\n\tif(keptObjects.length){\n\t\tthis.reset(keptObjects[0].left, keptObjects[0].top);\n\t\tindex = 0;\n\t\tlength = keptObjects.length;\n\t\tfor(; index < length; index++){\n\t\t\tthis.insert(keptObjects[index]);\n\t\t}\n\t} else {\n\t\tthis.reset();\n\t}\n\t\n\treturn rejectedObjects;\n};\n"],"sourceRoot":"/source/"}